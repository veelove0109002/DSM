#
# Copyright (C) 2022 Ing <https://github.com/wjz304>
#
# This is free software, licensed under the MIT License.
# See /LICENSE for more information.
#

name: Issues
on:
  issues:
    types: [opened, reopened]

  workflow_dispatch:
    inputs:
      iscustom:
        description: "设置为 true 启用自定义编译"
        type: boolean
        default: true
      model:
        description: "DSM 机型（例如 DS920+）"
        type: string
        required: false
      version:
        description: "DSM 版本（例如 7.2.1-69057）"
        type: string
        required: false
      format:
        description: "输出格式（img/ova/vmdk等）"
        type: string
        default: ""
      size:
        description: "镜像大小（2GB/4GB/8GB）"
        type: choice
        options:
          - 2GB
          - 4GB
          - 8GB
        default: 2GB
      language:
        description: "设置语言（如 zh_CN）"
        type: string
        default: ""
      template:
        description: "是否清空 SN/MAC 作为模板"
        type: boolean
        default: false
      sn:
        description: "自定义 SN"
        type: string
        default: ""
      macs:
        description: "自定义 MAC（逗号分隔）"
        type: string
        default: ""
      tips:
        description: "AddTips 内容"
        type: string
        default: ""
      kernel:
        description: "自定义 kernel（custom 或空）"
        type: string
        default: ""
      addons:
        description: "addons 列表（A:B,C:D）"
        type: string
        default: ""
      modules:
        description: "modules 列表（逗号分隔）"
        type: string
        default: ""

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@main
        with:
          fetch-depth: 0

      - name: Init Env
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          sudo timedatectl set-timezone "Asia/Shanghai"

      - name: Check Issues
        shell: python
        run: |
          # -*- coding: utf-8 -*-
          import json
          import os
          import subprocess

          def set_env(name, value):
              subprocess.call(f'echo "{name}<<EOF" >> $GITHUB_ENV', shell=True)
              subprocess.call(f'echo "{value}" >> $GITHUB_ENV', shell=True)
              subprocess.call(f'echo "EOF" >> $GITHUB_ENV', shell=True)
  
          event_name = os.environ.get('GITHUB_EVENT_NAME', '')

          fields = {
            "format": "",
            "size": "",
            "template": "",
            "language": "",
            "sn": "",
            "macs": "",
            "tips": "",
            "model": "",
            "version": "",
            "kernel": "",
            "addons": "",
            "modules": ""
          }

          iscustom = 'false'
          warinfo = 'false'

          if event_name == 'workflow_dispatch':
            iscustom = 'true' if os.environ.get('INPUT_ISCUSTOM', 'true').lower() == 'true' else 'false'
            for k in fields:
              env_name = f'INPUT_{k.upper()}'
              fields[k] = os.environ.get(env_name, "")
          else:
            issuetitle = """${{ github.event.issue.title }}"""
            issuebody = """${{ github.event.issue.body }}"""
            try:
              if issuetitle.strip().lower().startswith('custom'):
                jsonbody = json.loads(issuebody)
                iscustom = 'true'
                for k in fields:
                  fields[k] = jsonbody.get(k, "")
            except Exception:
              pass

            if iscustom == 'false':
              if not any(x in issuebody for x in ['DMI', 'CPU', 'NIC']):
                warinfo = 'true'

          set_env("iscustom", iscustom)
          set_env("warinfo", warinfo)
          set_env("event_name", event_name)
          for k, v in fields.items():
            set_env(k, v)

      - name: Update Comment Warinfo
        if: env.warinfo == 'true' && github.event_name == 'issues'
        uses: actions-cool/issues-helper@v3
        with:
          actions: "create-comment"
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            <img src="https://user-images.githubusercontent.com/5615843/235939097-6798da58-24fd-44cc-9970-c8d2f9609704.jpg" width="400">

            请填写以下信息.  
            Please fill in the following information.  

            Install ENV: (You can find it in the boot interface.)  
            * DMI:  
            * CPU:  
            * NIC:  (pid & vid)  

            RR version: (You can find it in the update menu.)  
            * RR:  
            * addons:  
            * modules:  
            * lkms:  

            DSM: 
            * model:  
            * version:  

            Issue:  

            logs:  

            (## 因为 log中存在 SN/MAC 等一些敏感信息, 当提供完整文件时请自行抹除他们, 当然你也可以发送到我的邮箱. ##)  
            (## Because the log contains some sensitive information such as SN/MAC, please delete them when providing the complete file. Of course, you can also send it to my email. ##)    
            ...

            (请先看一下#173、#175、#226 的内容)  
            (Plz review the content of #173, #175, #226 first)  
            ...

            (如果你只是说 XXX 不能用, 什么详细信息也不提供, 我也只能说感谢你的反馈.)  
            (If you just say XXX doesn't work without providing any details, I can only say thank you for your feedback.)  
            ... 

          emoji: heart

      - name: Update Comment Labels
        if: env.iscustom == 'true' && github.event_name == 'issues'
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'add-labels'
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          labels: 'custom,${{ env.model }}'

      - name: Update Comment Building
        if: env.iscustom == 'true' && github.event_name == 'issues'
        id: comment
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'create-comment'
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            Hi @${{ github.event.issue.user.login }}.  
            RR-${{ env.model }} building (Usually about 5 minutes) ...  
            > ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}  
            ----
          emoji: heart

      - name: Run Build
        if: env.iscustom == 'true'
        run: |
          # 累了, 毁灭吧!

          sudo apt update
          sudo apt install -y locales busybox dialog gettext sed gawk jq curl
          sudo apt install -y python-is-python3 python3-pip libelf-dev qemu-utils dosfstools cpio xz-utils lz4 lzma bzip2 gzip zstd

          . scripts/func.sh "${{ secrets.RRORG }}"

          REPO="${{ github.server_url }}/${{ github.repository }}"
          PRERELEASE="true"

          TAG=""
          
          # Method 1: Try GitHub API for tags (for prerelease)
          if [ "${PRERELEASE}" = "true" ]; then
            echo "Attempting to get latest tag from GitHub API..."
            TAG="$(curl -skL --connect-timeout 10 -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ github.repository }}/tags" | jq -r '.[0].name // empty')"
          else
            echo "Attempting to get latest release from GitHub API..."
            TAG="$(curl -skL --connect-timeout 10 -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ github.repository }}/releases/latest" | jq -r '.tag_name // empty')"
          fi
          
          # Method 2: Try parsing HTML tags page (fallback)
          if [ -z "${TAG}" ] || [ "${TAG}" = "null" ]; then
            echo "API method failed, trying HTML parsing method..."
            TAG="$(curl -skL --connect-timeout 10 "${REPO}/tags" | grep -oP '/refs/tags/[^"]+\.zip' | sed -E 's|/refs/tags/(.*)\.zip.*|\1|' | sort -rV | head -1 || true)"
          fi
          
          # Method 3: Use git tags (fallback)
          if [ -z "${TAG}" ] || [ "${TAG}" = "null" ]; then
            echo "HTML parsing failed, trying git tags method..."
            git fetch --tags --quiet || true
            TAG="$(git tag -l | grep -v '^$' | sort -rV | head -1 || true)"
          fi
          
          # Clean up tag by removing 'v' prefix if present
          if [ -n "${TAG}" ] && [ "${TAG}" != "null" ]; then
            [ "${TAG:0:1}" = "v" ] && TAG="${TAG:1}"
          fi
          
          # Verify TAG was retrieved successfully
          if [ -z "${TAG}" ] || [ "${TAG}" = "null" ]; then
            echo "❌ Failed to retrieve TAG using all methods"
            echo "Available git tags: $(git tag -l | head -5 || echo 'none')"
            echo "Repository: ${REPO}"
            exit 1
          fi
          
          echo "✓ Using TAG: ${TAG}"
          rm -f rr-*.img.zip rr.img.zip
          
          # Download the file with proper error handling
          DOWNLOAD_URL="${REPO}/releases/download/"
          
          # Try multiple download URL formats
          download_successful=0
          downloaded_file=""
          
          # Format 1: with v-prefix in tag and URL
          if [ ${download_successful} -eq 0 ]; then
            echo "Trying download URL: ${DOWNLOAD_URL}v${TAG}/rr-${TAG}.img.zip"
            STATUS=$(curl -kL --connect-timeout 15 -w "%{http_code}" -o "rr-${TAG}.img.zip" "${DOWNLOAD_URL}v${TAG}/rr-${TAG}.img.zip" 2>/dev/null || echo "000")
            if [ ${STATUS:-0} -eq 200 ] && [ -f "rr-${TAG}.img.zip" ] && [ -s "rr-${TAG}.img.zip" ]; then
              download_successful=1
              downloaded_file="rr-${TAG}.img.zip"
              echo "✓ Downloaded successfully: ${downloaded_file}"
            else
              rm -f "rr-${TAG}.img.zip"
            fi
          fi
          
          # Format 2: without v-prefix
          if [ ${download_successful} -eq 0 ]; then
            echo "Trying download URL: ${DOWNLOAD_URL}${TAG}/rr-${TAG}.img.zip"
            STATUS=$(curl -kL --connect-timeout 15 -w "%{http_code}" -o "rr-${TAG}.img.zip" "${DOWNLOAD_URL}${TAG}/rr-${TAG}.img.zip" 2>/dev/null || echo "000")
            if [ ${STATUS:-0} -eq 200 ] && [ -f "rr-${TAG}.img.zip" ] && [ -s "rr-${TAG}.img.zip" ]; then
              download_successful=1
              downloaded_file="rr-${TAG}.img.zip"
              echo "✓ Downloaded successfully: ${downloaded_file}"
            else
              rm -f "rr-${TAG}.img.zip"
            fi
          fi
          
          # Format 3: try with different filename pattern (without TAG in filename)
          if [ ${download_successful} -eq 0 ]; then
            echo "Trying download URL: ${DOWNLOAD_URL}v${TAG}/rr.img.zip"
            STATUS=$(curl -kL --connect-timeout 15 -w "%{http_code}" -o "rr.img.zip" "${DOWNLOAD_URL}v${TAG}/rr.img.zip" 2>/dev/null || echo "000")
            if [ ${STATUS:-0} -eq 200 ] && [ -f "rr.img.zip" ] && [ -s "rr.img.zip" ]; then
              download_successful=1
              downloaded_file="rr.img.zip"
              echo "✓ Downloaded successfully: ${downloaded_file}"
            else
              rm -f "rr.img.zip"
            fi
          fi
          
          # Format 4: try without v-prefix and different filename
          if [ ${download_successful} -eq 0 ]; then
            echo "Trying download URL: ${DOWNLOAD_URL}${TAG}/rr.img.zip"
            STATUS=$(curl -kL --connect-timeout 15 -w "%{http_code}" -o "rr.img.zip" "${DOWNLOAD_URL}${TAG}/rr.img.zip" 2>/dev/null || echo "000")
            if [ ${STATUS:-0} -eq 200 ] && [ -f "rr.img.zip" ] && [ -s "rr.img.zip" ]; then
              download_successful=1
              downloaded_file="rr.img.zip"
              echo "✓ Downloaded successfully: ${downloaded_file}"
            else
              rm -f "rr.img.zip"
            fi
          fi
          
          # Format 5: Try with a common release filename pattern
          if [ ${download_successful} -eq 0 ]; then
            echo "Trying download URL: ${DOWNLOAD_URL}latest/rr.img.zip"
            STATUS=$(curl -kL --connect-timeout 15 -w "%{http_code}" -o "rr.img.zip" "${DOWNLOAD_URL}latest/rr.img.zip" 2>/dev/null || echo "000")
            if [ ${STATUS:-0} -eq 200 ] && [ -f "rr.img.zip" ] && [ -s "rr.img.zip" ]; then
              download_successful=1
              downloaded_file="rr.img.zip"
              echo "✓ Downloaded successfully: ${downloaded_file}"
            else
              rm -f "rr.img.zip"
            fi
          fi
          
          # Check if download was successful
          if [ ${download_successful} -eq 0 ] || [ -z "${downloaded_file}" ] || [ ! -f "${downloaded_file}" ]; then
            echo "❌ Download failed for all URL formats"
            echo "TAG used: ${TAG}"
            echo "Repository: ${REPO}"
            echo "Available files: $(ls -la *.zip 2>/dev/null || echo 'No zip files found')"
            echo "Trying to list available releases..."
            curl -skL --connect-timeout 10 "${REPO}/releases" | grep -oP '/releases/tag/[^"]+' | head -5 || echo "Could not list releases"
            exit 1
          fi

          echo "Unzipping ${downloaded_file}..."
          mkdir -p rr
          # Unzip the downloaded file - try to extract rr.img from the zip
          if ! unzip -q "${downloaded_file}" -d rr rr.img 2>/dev/null; then
            echo "Failed to extract rr.img directly, listing zip contents..."
            unzip -l "${downloaded_file}" | head -20
            # Try extracting all files and find rr.img
            unzip -q "${downloaded_file}" -d rr
            # Look for rr.img in the extracted directory
            if [ -f "rr/rr.img" ]; then
              echo "✓ Found rr.img after full extraction"
            elif [ -f "rr.img" ]; then
              mv rr.img rr/rr.img
              echo "✓ Found rr.img in root, moved to rr/rr.img"
            else
              echo "❌ Failed to find rr.img in ${downloaded_file}"
              echo "Contents of rr directory: $(find rr -type f 2>/dev/null | head -10 || echo 'rr directory not found')"
              exit 1
            fi
          else
            echo "✓ Successfully extracted rr.img"
          fi
          
          # Verify that rr/rr.img was created and is not empty
          if [ ! -f "rr/rr.img" ] || [ ! -s "rr/rr.img" ]; then
            echo "❌ Failed to extract valid rr.img from ${downloaded_file}"
            echo "File exists: $([ -f "rr/rr.img" ] && echo 'yes' || echo 'no')"
            echo "File size: $(stat -f%z "rr/rr.img" 2>/dev/null || stat -c%s "rr/rr.img" 2>/dev/null || echo 'unknown')"
            exit 1
          fi
          
          echo "✓ Successfully extracted rr.img ($(du -h rr/rr.img | cut -f1))"

          echo "TAG=${TAG}" >> $GITHUB_ENV

          case "${{ env.size }}" in
            2GB)
              echo "2GB"
              ;;
            4GB)
              echo "4GB"
              resizeImg rr/rr.img +2048M
              ;;
            8GB)
              echo "8GB"
              resizeImg rr/rr.img +6144M
              ;;
            *)
              echo "unknown size"
              ;;
          esac

          LOOPX=$(sudo losetup -f)
          sudo losetup -P "${LOOPX}" rr/rr.img

          echo "Building..."
          {
            echo ". menu.sh"
            [ -n "${{ env.language }}" ] && echo "echo \"${{ env.language }}.UTF-8\" >/mnt/p1/.locale"
            [ -n "${{ env.tips }}" ] && echo "echo -e \"${{ env.tips }}\" >/mnt/p3/AddTips"
            [ -n "${{ env.kernel }}" ] && echo "writeConfigKey \"kernel\" \"${{ env.kernel }}\" \"\${USER_CONFIG_FILE}\""
            echo "menu.sh modelMenu \"${{ env.model }}\""
            echo "menu.sh productversMenu \"${{ env.version }}\""
            [ -n "${{ env.addons }}" ] && { 
              echo "writeConfigKey \"addons\" \"{}\" \"\${USER_CONFIG_FILE}\""
              IFS=',' read -ra ADDON_ARR <<< "${{ env.addons }}"
              for A in "${ADDON_ARR[@]}"; do
                if echo "${A}" | grep -qE '^[^:]+:[^:]+$'; then
                  KEY="$(echo "${A}" | cut -d':' -f1 | xargs)"
                  VAL="$(echo "${A}" | cut -d':' -f2 | xargs)"
                else
                  KEY="${A}"
                  VAL=""
                fi
                echo "writeConfigKey \"addons.\\\"${KEY}\\\"\" \"${VAL}\" \"\${USER_CONFIG_FILE}\""
              done
            }
            [ ! "custom" = "${{ env.kernel }}" ] && [ -n "${{ env.modules }}" ] && {
              echo "writeConfigKey \"modules\" \"{}\" \"\${USER_CONFIG_FILE}\""
              echo "mergeConfigModules \"$(echo "${{ env.modules }}" | tr ',' '\n')\" \"\${USER_CONFIG_FILE}\""
            }
            echo "menu.sh make"
            echo "menu.sh cleanCache"
            [ -n "${{ env.sn }}" ] && echo "writeConfigKey \"sn\" \"${{ env.sn }}\" \"\${USER_CONFIG_FILE}\""
            [ -n "${{ env.macs }}" ] && {
              MACS=($(echo "${{ env.macs }}" | sed 's/[:-]//g' | sed 's/.*/\U&/' | sed 's/[;,]/ /g'))
              [ -n "${MACS[0]}" ] && echo "writeConfigKey \"mac1\" \"${MACS[0]}\" \"\${USER_CONFIG_FILE}\""
              [ -n "${MACS[1]}" ] && echo "writeConfigKey \"mac2\" \"${MACS[1]}\" \"\${USER_CONFIG_FILE}\""
            }
            [ "true" = "${{ env.template }}" ] && {
              echo "writeConfigKey \"sn\" \"\" \"\${USER_CONFIG_FILE}\""
              echo "writeConfigKey \"mac1\" \"\" \"\${USER_CONFIG_FILE}\""
              echo "writeConfigKey \"mac2\" \"\" \"\${USER_CONFIG_FILE}\""
            }
          } > build.sh
          chmod +x build.sh

          docker pull wjz304/rr:${TAG}
          docker run --rm --privileged -p 7681:7681 -p 7304:7304 -p 7080:7080 -p 7022:22 -v ${PWD}/build.sh:/opt/rr/build.sh wjz304/rr:${TAG} bash build.sh

          sudo losetup --detach "${LOOPX}"

          ls rr -al

          {
            echo "RR: "
            echo "  VERSION: ${TAG}"
            echo "  CUSTOM:  ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            echo
            echo "After the image is written to the disk, it will boot directly into DSM without the need to compile again."
            echo "Of course, you can also modify the settings yourself."
          } >README.txt

          case "${{ env.format }}" in
            ova)
              echo "OVA"
              convertova "rr/rr.img" "rr/rr.ova"
              (cd rr && sha256sum rr.ova >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.ova.zip" -j rr/rr.ova sha256sum README.txt
              ;;
            vmx)
              echo "VMX"
              convertvmx "rr/rr.img" "rr.vmx"  # rr.vmx is a directory
              (cd rr.vmx && sha256sum * >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.vmx.zip" -r rr.vmx sha256sum README.txt
              ;;
            vmdk)
              echo "VMDK"
              qemu-img convert rr/rr.img -O vmdk -o 'adapter_type=lsilogic,subformat=monolithicSparse,compat6' rr/rr.vmdk
              (cd rr && sha256sum rr.vmdk >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.vmdk.zip" -j rr/rr.vmdk sha256sum README.txt
              ;;
            flat)
              echo "FLAT"
              qemu-img convert rr/rr.img -O vmdk -o 'adapter_type=lsilogic,subformat=monolithicFlat,compat6' rr/rr.vmdk
              (cd rr && sha256sum rr*.vmdk >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.flat.zip" -j rr/rr*.vmdk sha256sum README.txt
              ;;
            vhd)
              echo "VHD"
              qemu-img convert rr/rr.img -O vpc rr/rr.vhd
              createvmc "rr/rr.vhd" "rr/rr.vmc"
              (cd rr && sha256sum rr.vhd >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.vhd.zip" -j rr/rr.vmc rr/rr.vhd sha256sum README.txt
              ;;
            vhdx)
              echo "VHDX"
              qemu-img convert rr/rr.img -O vhdx -o subformat=dynamic rr/rr.vhdx
              (cd rr && sha256sum rr.vhdx >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.vhdx.zip" -j rr/rr.vhdx sha256sum README.txt
              ;;
            *)
              echo "IMG"
              (cd rr && sha256sum rr.img >../sha256sum)
              zip -9 "rr-${{ env.model }}-${TAG}-${{ github.run_id }}.img.zip" -j rr/rr.img sha256sum README.txt
          esac

      - name: Upload to Artifacts
        if: env.iscustom == 'true' && success()
        uses: actions/upload-artifact@v4
        with:
          name: rr-${{ env.model }}-${{ env.TAG }}
          path: |
            rr-${{ env.model }}-${{ env.TAG }}*.zip
          retention-days: 5

      - name: Update Comment Success
        if: env.iscustom == 'true' && success() && github.event_name == 'issues'
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'update-comment'
          token: ${{ secrets.GITHUB_TOKEN }}
          comment-id: ${{ steps.comment.outputs.comment-id }}
          update-mode: replace
          body: |
            Hi @${{ github.event.issue.user.login }}.  
            RR-${{ env.model }}-${{ env.TAG }} build success, please download the attachment from the below link (Attachments are only kept for 5 days).
            > ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}  
            ----
          emoji: hooray

      - name: Update Comment Fail
        if: env.iscustom == 'true' && failure() && github.event_name == 'issues'
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'update-comment'
          token: ${{ secrets.GITHUB_TOKEN }}
          comment-id: ${{ steps.comment.outputs.comment-id }}
          update-mode: replace
          body: |
            Hi @${{ github.event.issue.user.login }}.  
            RR-${{ env.model }}-${{ env.TAG }} build failed, please try again.  
            > ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}  
            ----
          emoji: confused

      - name: Close Issues
        if: env.iscustom == 'true' && github.event_name == 'issues'
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'close-issue'
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
